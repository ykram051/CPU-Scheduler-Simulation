\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}

% Configuration of listings for Python code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=Python
}

\lstset{style=pythonstyle}

\title{Report on CPU Scheduler Simulation: \\
Analysis of Algorithms and Implementation Choices Justification}
\author{Fadel Fatima Zahra \and Ikram Benfellah}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents a detailed analysis of the CPU scheduler simulation project. We examine the different scheduling algorithms implemented, the project structure, and the technical choices that guided our implementation. The algorithms studied include First-Come-First-Served (FCFS), Shortest Job First (SJF), Priority Scheduling, Round Robin (RR), and Priority Round Robin, each with its own characteristics and advantages in different usage contexts. This project also offers an interactive user interface via Streamlit to visualize and compare the performance of the different algorithms.
\end{abstract}

\tableofcontents

\newpage

\section{Introduction}
\subsection{Project Context}
Process scheduling is a fundamental aspect of modern operating systems. It determines how CPU resources are allocated to the various processes waiting to be executed. An efficient scheduling algorithm aims to maximize CPU utilization while minimizing waiting and response times for processes.

\subsection{Objectives}
This project has several objectives:
\begin{itemize}
    \item Implement different CPU scheduling algorithms
    \item Compare their performance using standard metrics
    \item Provide a clear visualization of their operation
    \item Offer an interactive interface for experimentation and learning
\end{itemize}

\section{Project Structure}
The simulation was designed with an object-oriented architecture, which facilitates code extension and maintenance. The structure includes:

\begin{itemize}
    \item \textbf{Process Class}: Represents a process with its attributes (arrival time, burst time, priority, etc.)
    \item \textbf{Scheduler Class (base)}: Defines the common interface for all scheduling algorithms
    \item \textbf{Derived Classes}: Specific implementations of each scheduling algorithm
    \item \textbf{Metrics Module}: Performance calculation (average waiting time, turnaround time, etc.)
    \item \textbf{Visualization Module}: Generation of charts and diagrams
    \item \textbf{User Interface}: Streamlit application for interaction
\end{itemize}

\section{Implemented Scheduling Algorithms}
\subsection{First-Come-First-Served (FCFS)}
\subsubsection{Description}
FCFS is the simplest scheduling algorithm, based on the principle of "first come, first served". Processes are executed in the order of their arrival in the queue.

\subsubsection{Characteristics}
\begin{itemize}
    \item \textbf{Non-preemptive}: Once a process starts execution, it continues until it is completed
    \item \textbf{Simple to implement}: Uses a simple FIFO (First In, First Out) queue
    \item \textbf{Fair}: Treats all processes according to their arrival order
    \item \textbf{Predictable}: Waiting time can be easily calculated
\end{itemize}

\subsubsection{Advantages and Disadvantages}
\begin{itemize}
    \item \textbf{Advantages}:
    \begin{itemize}
        \item Simple implementation
        \item No starvation: all processes are eventually executed
    \end{itemize}
    \item \textbf{Disadvantages}:
    \begin{itemize}
        \item "Convoy effect": a long process can delay all processes that follow it
        \item High average waiting time if long processes arrive early
        \item Does not prioritize short or urgent processes
    \end{itemize}
\end{itemize}

\subsubsection{Implementation Justification}
We chose to implement FCFS as a reference point, as it is the most fundamental algorithm. Despite its limitations, it provides an essential comparison baseline to evaluate the performance of other algorithms.

The implementation in our project follows exactly the conceptual model of the algorithm:
\begin{enumerate}
    \item Sort processes by arrival time
    \item Execute processes in this order
    \item No interruption of processes during execution
\end{enumerate}

\subsection{Shortest Job First (SJF)}
\subsubsection{Description}
SJF is a non-preemptive algorithm that selects the process with the shortest execution time (burst time) among those available in the queue.

\subsubsection{Characteristics}
\begin{itemize}
    \item \textbf{Non-preemptive}: Like FCFS, once a process starts, it runs to completion
    \item \textbf{Optimizes average waiting time}: Mathematically proven to minimize average waiting time
    \item \textbf{Requires prior knowledge}: Demands knowing in advance the execution time of each process
\end{itemize}

\subsubsection{Advantages and Disadvantages}
\begin{itemize}
    \item \textbf{Advantages}:
    \begin{itemize}
        \item Minimal average waiting time
        \item Maximum number of completed processes per time unit
    \end{itemize}
    \item \textbf{Disadvantages}:
    \begin{itemize}
        \item Risk of starvation for long processes
        \item Difficult to implement in real systems as execution time is rarely known in advance
        \item Not optimal for interactive systems
    \end{itemize}
\end{itemize}

\subsubsection{Implementation Justification}
We implemented SJF to demonstrate how a theoretically optimal algorithm in terms of average waiting time works. To work around the limitation of prior knowledge of execution time, our simulation assumes that these times are known in advance.

The implementation selects, at each step, the available process with the shortest execution time, which significantly reduces the average waiting time compared to FCFS.

\subsection{Priority Scheduling}
\subsubsection{Description}
The priority scheduling algorithm selects processes based on their assigned priority value (lower value means higher priority).

\subsubsection{Characteristics}
\begin{itemize}
    \item \textbf{Non-preemptive} in our implementation
    \item \textbf{Based on priority value}: High priority processes are executed before low priority ones
    \item \textbf{Flexible}: Priorities can be assigned according to different criteria (deadline, importance, I/O ratio, etc.)
\end{itemize}

\subsubsection{Advantages and Disadvantages}
\begin{itemize}
    \item \textbf{Advantages}:
    \begin{itemize}
        \item Allows for favoring critical processes
        \item Adaptable to different usage contexts
    \end{itemize}
    \item \textbf{Disadvantages}:
    \begin{itemize}
        \item High risk of starvation for low priority processes
        \item Requires an aging mechanism in real systems
        \item Can be subject to priority inversions if poorly managed
    \end{itemize}
\end{itemize}

\subsubsection{Implementation Justification}
Priority scheduling was implemented to illustrate how operating systems can take into account the relative importance of processes. In our implementation, at each step, the available process with the highest priority (lowest numerical value) is selected for execution.

This implementation choice allows understanding the trade-offs between fairness and the importance given to certain processes, a crucial aspect in real-time systems and multi-user environments.

\subsection{Round Robin (RR)}
\subsubsection{Description}
The Round Robin algorithm is a preemptive approach that allocates a fixed time quantum to each process. Once this quantum is exhausted, the process is interrupted and placed at the end of the queue.

\subsubsection{Characteristics}
\begin{itemize}
    \item \textbf{Preemptive}: Interrupts the execution of a process after a fixed time quantum
    \item \textbf{Fair}: Each process receives an equal share of processor time
    \item \textbf{Parameterizable}: Performance heavily depends on the choice of time quantum
    \item \textbf{Uses a circular queue}
\end{itemize}

\subsubsection{Advantages and Disadvantages}
\begin{itemize}
    \item \textbf{Advantages}:
    \begin{itemize}
        \item Excellent response time for short processes
        \item Fair distribution of CPU time
        \item No starvation, all processes receive processor time
        \item Ideal for interactive and shared systems
    \end{itemize}
    \item \textbf{Disadvantages}:
    \begin{itemize}
        \item Overhead due to frequent context switches
        \item Performance sensitive to the choice of quantum
        \item Longer waiting time for short processes compared to SJF
    \end{itemize}
\end{itemize}

\subsubsection{Implementation Justification}
Round Robin was implemented because it is the most commonly used algorithm in multitasking operating systems, particularly for interactive applications. Our implementation uses a queue (deque in Python) to efficiently manage process rotation.

The choice of time quantum is parameterizable in our simulation, allowing observation of how different values affect system performance. This flexibility is essential for understanding the trade-offs between response time and overhead due to context switches.

\subsection{Priority Round Robin}
\subsubsection{Description}
Priority Round Robin combines the concepts of priority scheduling and Round Robin. Processes are first organized by priority levels, then within each level, the Round Robin algorithm is applied.

\subsubsection{Characteristics}
\begin{itemize}
    \item \textbf{Preemptive}: Like Round Robin, uses a time quantum
    \item \textbf{Hierarchical}: Organizes processes in priority queues
    \item \textbf{Hybrid}: Combines the advantages of priority and Round Robin approaches
\end{itemize}

\subsubsection{Advantages and Disadvantages}
\begin{itemize}
    \item \textbf{Advantages}:
    \begin{itemize}
        \item Ensures high priority processes are handled first
        \item Ensures fairness within each priority level
        \item Increased flexibility for complex systems
    \end{itemize}
    \item \textbf{Disadvantages}:
    \begin{itemize}
        \item Higher implementation complexity
        \item Risk of starvation for low priority processes
        \item Overhead related to managing multiple queues
    \end{itemize}
\end{itemize}

\subsubsection{Implementation Justification}
Priority Round Robin was chosen as an example of an advanced hybrid algorithm that could be used in environments requiring both responsiveness for priority processes and fairness within each priority level.

Our implementation uses a dictionary of queues (deques), one for each priority level, which allows efficient management while maintaining the necessary hierarchical structure.

\section{Evaluation Metrics}
To objectively compare the different algorithms, we implemented several standard metrics:

\subsection{Turnaround Time}
The total elapsed time between a process's arrival and its completion. This metric indicates the overall efficiency of the scheduler.

\[ \text{Turnaround Time} = \text{Completion Time} - \text{Arrival Time} \]

\subsection{Waiting Time}
The total time a process spends waiting in the queue.

\[ \text{Waiting Time} = \text{Turnaround Time} - \text{Burst Time} \]

\subsection{Response Time}
The time elapsed between a process's arrival and its first execution on the CPU.

\[ \text{Response Time} = \text{First Start Time} - \text{Arrival Time} \]

\subsection{Throughput}
The number of processes completed per time unit.

\[ \text{Throughput} = \frac{\text{Number of Completed Processes}}{\text{Total Time}} \]

\subsection{CPU Utilization}
Percentage of time during which the CPU is busy.

\[ \text{CPU Utilization} = \frac{\text{Total Burst Time}}{\text{Total Time}} \times 100\% \]

\section{Software Architecture}
\subsection{Object-Oriented Design}
Our simulation uses an object-oriented architecture with an emphasis on flexibility and extensibility. The abstract \texttt{Scheduler} class defines the common interface for all algorithms, which allows:
\begin{itemize}
    \item A uniform interface for all schedulers
    \item The ability to easily add new algorithms
    \item A clear separation between scheduling logic and other aspects of the system
\end{itemize}

\subsection{User Interface with Streamlit}
The application uses Streamlit to provide an interactive web interface that allows users to:
\begin{itemize}
    \item Generate processes randomly
    \item Manually define process characteristics
    \item Import and export process configurations in JSON format
    \item Select different scheduling algorithms
    \item Visualize results with Gantt charts and comparative graphs
\end{itemize}

This approach provides an interactive learning experience, ideal for understanding the nuances of different algorithms.

\section{Visualizations}
An important aspect of our project is the visualization of the behaviors of different algorithms. We implemented several types of visualizations:

\subsection{Gantt Chart}
Shows the order and duration of execution of each process on the time scale. This visualization is particularly useful for understanding how algorithms handle processes over time.

\subsection{Process Timeline}
Displays the complete lifecycle of each process, clearly showing waiting and execution periods.

\subsection{Comparative Graphs}
Allow direct comparison of the performance of different algorithms according to various metrics:
\begin{itemize}
    \item Average turnaround time
    \item Average waiting time
    \item Average response time
    \item CPU utilization
\end{itemize}

\section{Conclusion}
\subsection{Results Summary}
Our simulation demonstrates that each scheduling algorithm has its own strengths and weaknesses, and the optimal choice strongly depends on the usage context:

\begin{itemize}
    \item \textbf{FCFS} is simple but can lead to long waiting times
    \item \textbf{SJF} minimizes average waiting time but may cause starvation of long processes
    \item \textbf{Priority Scheduling} allows favoring important processes but also risks creating starvation
    \item \textbf{Round Robin} offers good responsiveness and fairness but with overhead related to context switches
    \item \textbf{Priority Round Robin} combines advantages and disadvantages of priority and Round Robin approaches
\end{itemize}

\subsection{Educational Implications}
This simulation constitutes a valuable educational tool for understanding the fundamental concepts of CPU scheduling and the inherent trade-offs of each approach. The interactive interface facilitates experimentation and learning.

\subsection{Future Improvements}
Several improvement axes can be considered to extend this project:
\begin{itemize}
    \item Implementation of additional algorithms (Multilevel Feedback Queue, Earliest Deadline First, etc.)
    \item Simulation of multi-core and multi-processor systems
    \item More detailed modeling of input/output operations
    \item Integration of aging mechanisms to prevent starvation
    \item Development of predefined test scenarios representing different workloads
\end{itemize}

\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{tanenbaum}
  Tanenbaum, A.S. \& Bos, H.,
  \textit{Modern Operating Systems},
  Pearson, 4th Edition, 2014.

\bibitem{silberschatz}
  Silberschatz, A., Galvin, P.B. \& Gagne, G.,
  \textit{Operating System Concepts},
  Wiley, 10th Edition, 2018.

\bibitem{stallings}
  Stallings, W.,
  \textit{Operating Systems: Internals and Design Principles},
  Pearson, 9th Edition, 2018.

\end{thebibliography}

\end{document}